<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://icyfe.github.io/icyblog/</id>
    <title>icyfe</title>
    <updated>2020-06-17T08:01:12.248Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://icyfe.github.io/icyblog/"/>
    <link rel="self" href="https://icyfe.github.io/icyblog/atom.xml"/>
    <subtitle>好好学习天天向上🌸</subtitle>
    <logo>https://icyfe.github.io/icyblog/images/avatar.png</logo>
    <icon>https://icyfe.github.io/icyblog/favicon.ico</icon>
    <rights>All rights reserved 2020, icyfe</rights>
    <entry>
        <title type="html"><![CDATA[变量对象]]></title>
        <id>https://icyfe.github.io/icyblog/post/bian-liang-dui-xiang/</id>
        <link href="https://icyfe.github.io/icyblog/post/bian-liang-dui-xiang/">
        </link>
        <updated>2020-06-17T08:00:51.000Z</updated>
        <content type="html"><![CDATA[<h2 id="什么是变量对象variable-objectvo">什么是变量对象(Variable object，VO)？</h2>
<p>变量对象是执行上下文中的<strong>数据作用域</strong>，它存储了当前上下文的变量和函数声明。<br>
执行上下文一般分三种 1.全局执行上下文。 2.函数执行上下文<br>
3.evel(一般不推荐使用)</p>
<h2 id="全局上下文的变量对象">全局上下文的变量对象</h2>
<p>当程序运行的时候，全局上下文会预先定义一个全局对象，包含了一些常用的方法，如:Math,document...<br>
由这些组成的全局对象就是全局上下文的变量对象</p>
<h2 id="函数执行上下文的变量对象">函数执行上下文的变量对象</h2>
<p>而函数的上下文变量对象和全局的不同它分为两个阶段创建阶段和执行阶段，它的创建过程主要由三部分组成 1.建立 Argument 对象，检查当前上下文的形参建立相应的属性。 2.检查函数声明.创建指向函数的引用 3.检查变量声明，由 var 关键字声明的变量(let 和 const 不会加入到变量对象创建阶段会进入暂时性死区)，通过变量提升会初始化为 undefined 如果遇到同名函数声明会跳过。<br>
举个栗子：</p>
<pre><code class="language-js">function a() {
  console.log(b); //function b
  function b() {
    console.log('Hello');
  }
  var b = 'Hi';
  var c = 'Hi2';
  console.log(b); //'Hi'
}
</code></pre>
<p>上面的栗子在创建阶段函数和变量提升，因此打印出函数 b,有人会疑惑为什么不是 undefined 后面的覆盖前面的啊，因为在上面第三点中提到了 如果 var 声明的变量遇到同名的会跳过,后面的 b 输出 hi 因为是在执行阶段赋值产生了覆盖行为。<br>
创建过程如下</p>
<pre><code class="language-js">//创建阶段
VO:{
        argument:{
            length:0,
        }
        b:&lt; reference&gt; function b(){},
        c:undefined
    }

//执行阶段
AO:{
        argument:{
            length:0,
        }
        b:Hi,
        c:Hi2
    }
</code></pre>
<p>这里不禁再次疑问 AO 是什么，其实 AO 就是 VO 两个是指的一个对象，只是在不同阶段发生了变化，当可执行函数在执行栈的最顶端时，也就是当前函数执行上下文被执行，VO 就变成了 AO，并进行一系列的赋值操作<br>
在来看一个</p>
<pre><code class="language-js">function a(b) {
  console.log(b); //function b{}
  function b() {
    console.log('Hello');
  }
  var b = 'Hi';
  var c = 'Hi2';
  console.log(b);
}
a(1);
</code></pre>
<p>这个明明有传参数为什么还是最后输出来的还是 function b 呢，这里又有一个知识点当传入的形参和函数声明同名时，函数声明会覆盖形参<br>
总结一下： 1.全局上下文的变量对象就是 window 2.函数上下文变量对象由形参，函数声明，变量声明组成 3.函数上下文变量对象分为创建阶段和声明阶段，两个阶段都会对属性进行更改 1.创建阶段：如果 function 关键字声明的变量与形参同名将会覆盖原有属性，var 声明的变量如果与<br>
function 声明的重名了将不会影响到已经声明的函数，会跳过，其他通过 var 声明的会初始化为<br>
undefined 2. 执行阶段:这个阶段会再次对变量进行修改，进行相应的赋值，对任何已经有的值都会进行覆盖。列<br>
如函数声明</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数万条数据优化]]></title>
        <id>https://icyfe.github.io/icyblog/post/shu-wan-tiao-shu-ju-you-hua/</id>
        <link href="https://icyfe.github.io/icyblog/post/shu-wan-tiao-shu-ju-you-hua/">
        </link>
        <updated>2020-06-17T06:25:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="当一个页面的列表有大量数据如有-100000-条如何优化渲染">当一个页面的列表有大量数据如有 100000 条如何优化渲染？</h2>
<p>当我们将 10W 条全部在页面加载的时候渲染出来，可以很明显的感受到加载速度缓慢并且可以看到 DOM 树非常非常的长当快速上下滚动时候，偶尔还会卡顿，下面我们用代码实现下这里用 vue 实现</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;list-view&quot;&gt;
    &lt;!-- @scroll=&quot;handleScroll($event)&quot; --&gt;
    &lt;div class=&quot;list-view-item&quot; :style=&quot;{ height: itemHeight + 'px' }&quot; v-for=&quot;item in data&quot; :key=&quot;item.value&quot;&gt;{{ item }}&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
​
&lt;style&gt;
.list-view {
  height: 600px;
  width: 200px;
  overflow: auto;
  position: relative;
  border: 1px solid #666;
}
​ .list-view-phantom {
  position: absolute;
  left: 0;
  top: 0;
  right: 0;
  z-index: -1;
}
.list-view-content {
  position: absolute;
  height: 600px;
  z-index: 99;
  left: 0;
  right: 0;
  top: 0;
}
​ .list-view-item {
  padding: 5px;
  color: #000;
  height: 30px;
  width: 200px;
  line-height: 30px;
  box-sizing: border-box;
}
&lt;/style&gt;
&lt;script&gt;
export default {
  props: {
    itemHeight: {
      type: Number,
      default: 30
    }
  },
  mounted() {},
  created() {
    for (let i = 0; i &lt; 100000; i++) {
      this.data.push('第' + i + '条');
    }
  },
  data() {
    return {
      data: []
    };
  },
  methods: {}
};
&lt;/script&gt;
</code></pre>
<p>效果图<br>
<img src="https://user-images.githubusercontent.com/44893721/54416187-a9439f80-4739-11e9-8cb5-bf7af0ba85c6.gif" alt="cc" loading="lazy"><br>
可以很明显的看到当快速滑动时画面的卡顿</p>
<h2 id="如何优化">如何优化？</h2>
<p>我们知道屏幕都是有一个可视范围的，我们因此就可以当节点在可视范围时就显示出来，当节点不在可视范围时候就移除，因此我们只要渲染可视范围的节点即可<br>
画个图<br>
<img src="https://user-images.githubusercontent.com/44893721/54416872-9762fc00-473b-11e9-87d6-9e0791a86d91.jpg" alt="1552636795(1)" loading="lazy"></p>
<p>主要分以下几个步骤。 1.计算窗口可视范围，并根据可视范围计算出一屏幕可见的节点。 2.监听滚动计算每次滚动完成后的初始节点和末尾节点 3.根据新的起始节点替换可视区域数据<br>
具体实现参考了一篇网上的博客具体链接会在下面注明：</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;list-view&quot; @scroll=&quot;handleScroll($event)&quot;&gt;
    &lt;div class=&quot;list-view-phantom&quot; :style=&quot;{ height: listheight + 'px' }&quot;&gt;&lt;/div&gt;
    &lt;div ref=&quot;content&quot; class=&quot;list-view-content&quot;&gt;
      &lt;div class=&quot;list-view-item&quot; :style=&quot;{ height: itemHeight + 'px' }&quot; v-for=&quot;item in visibleData&quot; :key=&quot;item.value&quot;&gt;{{ item }}&lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  props: {
    itemHeight: {
      type: Number,
      default: 30
    }
  },
  mounted() {
    this.visibleCount = Math.ceil(this.$el.clientHeight / this.itemHeight); //计算可视区域高度可显示数据条目数
    this.start = 0; //起始数据下标
    this.end = this.start + this.visibleCount; //末尾最后一条
    this.visibleData = this.data.slice(this.start, this.end); // 初始化可视区域数据
  },
  created() {
    for (let i = 0; i &lt; 100000; i++) {
      this.data.push('第' + i + '条'); //初始化10W条数据
    }
    this.listheight = this.data.length * 30; //计算10w条元素的总高度
  },
  data() {
    return {
      data: [],
      start: 0,
      end: null,
      visibleCount: null, //
      visibleData: [],
      scrollTop: 0,
      listheight: ''
    };
  },
  methods: {
    //滚动监听
    handleScroll(event) {
      const scrollTop = this.$el.scrollTop; //监听距离顶部高度
      const fixedScrollTop = scrollTop - (scrollTop % 30); //修复移动位置不精确问题
      this.$refs.content.style.webkitTransform = `translate3d(0, ${fixedScrollTop}px, 0)`; //实时位移
      this.start = Math.floor(scrollTop / 30); //重新计算起始条目下标
      this.end = this.start + this.visibleCount; // 重新计算末尾小标
      this.visibleData = this.data.slice(this.start, this.end); //重新装载可视区域数据
    }
  }
};
&lt;/script&gt;
&lt;style&gt;
.list-view {
  height: 400px;
  width: 200px;
  overflow: auto;
  position: relative;
  border: 1px solid #666;
}
​ .list-view-phantom {
  position: absolute;
  left: 0;
  top: 0;
  right: 0;
  z-index: -1;
}
.list-view-content {
  position: absolute;
  height: 400px;
  z-index: 99;
  left: 0;
  right: 0;
  top: 0;
}
​ .list-view-item {
  padding: 5px;
  color: #000;
  height: 30px;
  width: 200px;
  line-height: 30px;
  box-sizing: border-box;
}
&lt;/style&gt;
</code></pre>
<p>来看看实现后的快速滚动的效果<br>
<img src="https://user-images.githubusercontent.com/44893721/54417786-1c4f1500-473e-11e9-8602-0e19d27c6176.gif" alt="ccc" loading="lazy"><br>
<img src="https://user-images.githubusercontent.com/44893721/54417902-60421a00-473e-11e9-938e-10e19e226590.gif" alt="aaa" loading="lazy"></p>
<p>这里主要利用了绝对布局，利用两个绝对布局一个没有任何元素，但高度为所有节点高度的合，利用这个撑开父节点使其滚动条出现，第二个节点高度和可视区域高度一致，当不断滚动的时候利用位移调整位置。<br>
画个图<br>
<img src="https://user-images.githubusercontent.com/44893721/54418395-cb402080-473f-11e9-9d0f-7dd49266f1fd.jpg" alt="1552638608(1)" loading="lazy"></p>
<p>无论如何滑动，可视区域的范围就那么大，因此不会造成页面大量 DOM 节点的存在导致卡顿问题的出现<br>
参考实现https://zhuanlan.zhihu.com/p/26022258</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello~fine]]></title>
        <id>https://icyfe.github.io/icyblog/post/hello/</id>
        <link href="https://icyfe.github.io/icyblog/post/hello/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="记录生活-记录点滴">记录生活， 记录点滴</h2>
]]></content>
    </entry>
</feed>